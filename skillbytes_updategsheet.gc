function listFolderContents() {
  var foldername = 'SkillBytes';
  var folderlisting = 'listing of folder ' + foldername;
  
  var folders = DriveApp.getFoldersByName(foldername)
  var folder = folders.next();
  var contents = folder.getFiles();
  
  var sheet_url="https://docs.google.com/spreadsheets/d/1lXwQPS2NYVa1C1WuUW-kYpVhIqBHs8njRrgo_aowSng/";
  //var sheet_url="https://docs.google.com/spreadsheets/d/10Bvl-rYXiyE_bt2-KvCqnkaBO48WEi2WUGA0Kts_-fU/";
  var ss = SpreadsheetApp.openByUrl(sheet_url)
      

  var sheet = ss.getActiveSheet();

  sheet.clear();
  sheet.appendRow( ['id','name', 'hashtag_list', 'date_dreated', 'hashtag', 'url', 'contributor', 'difficulty', 'domain'] );
  
  var file;
  var name;
  var link;
  var description;
  var Date_Created;
  var id_;
  var hashes_ = [''];
  var hashes_str = '';
  var contributors;
  var docText;
  var difficulty = '';
  var domains_ = [];
  var domains_str = '';
   
  while(contents.hasNext()) {
    file = contents.next();
    name = file.getName();
    link = file.getUrl();
    name_link_formula_txt = "=hyperlink(\""+link+"\",\""+name+"\")"
    description=file.getDescription();
    Date_Created=file.getDateCreated();
    id_=file.getId();

    var docText=DocumentApp.openByUrl(link).getBody().getText();

    // get hashtags
    if( docText.match('#') ){
      var hashes_=docText.match(/(?<!\w)#\w+/g);// these aren't unique
      //var hashes_=DocumentApp.openByUrl(link).getBody().getText().match(/(?<!\w)#\w+/g);// these aren't unique
      var hashes_=hashes_.map(name => name.toLowerCase());//all lowercase

      //########################################################################
      // START fix hash names
      // e.g. #colab and #colabnotebook could co-exist. So replace all to #colab then later just take distinct hashes
      hash_clean_map = {'^#.*colab.*$':'#colab',
      '^#ml$':'#machinelearning',
      '^#.*tableau.*$':'#tableau',
      '^#bq$':'#bigquery',
      '^#gcp$':'#googlecloudplatform',
      }

      for(i=0;i<hashes_.length;i++){
        for(key in hash_clean_map){
        if(hashes_[i].match(key)){
            hashes_[i]=hash_clean_map[key];
            break
        }}
      }
      // END fix hash names
      //########################################################################

      var hashes_ = [...new Set(hashes_)]; //these are unique
      var hashes_ = hashes_.sort(); // now they are sorted
    } else {
      var hashes_=['']
    }

    // get contributor
    if( docText.match('@') ){
    //var contributors=docText.match(/@[a-zA-Z]+/g);// get contributor @...
    var contributors=docText.match(/@[a-zA-Z0-9]+/g).sort().join(', ');// get contributor @...
    }  else {
      var contributors=''
    }

    // get difficulty
    if( docText.match('\\[') && docText.match('\\]') ){
    //var contributors=docText.match(/@[a-zA-Z]+/g);// get contributor @...
    var difficulty=docText.match(/\[[a-zA-Z0-9]+\]/g).sort().join(', ').replace('[','').replace(']','');// get difficulty [...]...
    }  else {
      var difficulty=''
    }
    
    //hashes_str=hashes_.join(' ');
        
    //########################################################################
      // START domain mapping
      // e.g. #colab and #colabnotebook could co-exist. So replace all to #colab then later just take distinct hashes
      domain_map = {
      '^#appsscript$': 'Data',
      '^#bigquery$': 'Tools',
      '^#bq$': 'Tools',
      '^#colab$': 'Tools',
      '^#colabnotebook$': 'Tools',
      '^#googlecolabnotebook$': 'Tools',
      '^#googlecolab$': 'Tools',
      '^#createtable$': 'Data',
      '^#csv$': 'Data',
      '^#dataframe$': 'Tools',
      '^#dataingestion$': 'Techniques and Theory',
      '^#dataviz$': 'Techniques and Theory',
      '^#dplyr$': 'Techniques and Theory',
      '^#function$': 'Techniques and Theory',
      '^#gcp$': 'Data',
      '^#googlecloudplatform$': 'Data',
      '^#googlesheet$': 'Data',
      '^#js$': 'Tools',
      '^#linux$': 'Tools',
      '^#listcomprehension$': 'Techniques and Theory',
      '^#loops$': 'Techniques and Theory',
      '^#machinelearning$': 'Techniques and Theory',
      '^#ml$': 'Techniques and Theory',
      '^#pandas$': 'Tools',
      '^#pivot$': 'Data',
      '^#python$': 'Tools',
      '^#r$': 'Tools',
      '^#shell$': 'Techniques and Theory',
      '^#skillbyte$': 'Process and Frameworks',
      '^#tableau$': 'Tools',
      '^#vm$': 'Tools',

      '^.*colab.*$': 'Tools',
      '^.*notebook.*$': 'Tools',
      }

      for(i=0;i<hashes_.length;i++){
        domains_.push('None')
        for(key in domain_map){
        if(hashes_[i].match(key)){
            domains_[i] = domain_map[key];
            break
        }
        }
      }
      // END domain mapping
      //########################################################################


    // add an ALL hashtags row?
    //sheet.appendRow( [id_, name_link_formula_txt,hashes_str,Date_Created, link, contributors, difficulty, domains_] );    
    // add row for each hash tag
    for(i=0;i<hashes_.length;i++){
      hashes_str=hashes_[i];
      domains_str=domains_[i];
      sheet.appendRow( [id_, name_link_formula_txt,hashes_.join(' '),Date_Created, hashes_str, link, contributors, difficulty, domains_str] ); 
    }


  }
};
